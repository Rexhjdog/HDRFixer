using System.Buffers.Binary;
using System.Text;
using static HDRFixer.Core.ColorProfile.IccBinaryHelpers;

namespace HDRFixer.Core.ColorProfile;

public static class Mhc2ProfileWriter
{
    private static byte[] BuildMhc2Tag(double minNits, double maxNits, double[,] matrix3x4, double[,] regammaLut)
    {
        int lutSize = regammaLut.GetLength(1);
        using var ms = new MemoryStream();
        using var w = new BinaryWriter(ms);

        WriteTag(w, "MHC2");
        WriteBE32(w, 0); // Reserved
        WriteBE32(w, lutSize);
        WriteBE32(w, ToS15F16(minNits));
        WriteBE32(w, ToS15F16(maxNits));

        int matrixOffset = 32;
        int lut1Offset = 0; // Identity/Bypassed
        int lut2Offset = matrixOffset + 48; // Matrix is 3x4 * 4 bytes = 48 bytes

        WriteBE32(w, matrixOffset);
        WriteBE32(w, lut1Offset);
        WriteBE32(w, lut2Offset);

        for (int r = 0; r < 3; r++)
            for (int c = 0; c < 4; c++)
                WriteBE32(w, ToS15F16(matrix3x4[r, c]));

        for (int ch = 0; ch < 3; ch++)
        {
            WriteTag(w, "sf32");
            WriteBE32(w, 0); // Reserved
            for (int i = 0; i < lutSize; i++)
                WriteBE32(w, ToS15F16(regammaLut[ch, i]));
        }
        return ms.ToArray();
    }

    public static byte[] CreateProfile(string description, double maxNits, double minNits, double[,] matrix3x4, double[,] regammaLut)
    {
        var rXYZ = BuildXyzTag(0.4361, 0.2225, 0.0139);
        var gXYZ = BuildXyzTag(0.3851, 0.7169, 0.0971);
        var bXYZ = BuildXyzTag(0.1431, 0.0606, 0.7141);
        var wtpt = BuildXyzTag(0.9505, 1.0000, 1.0890);
        var lumi = BuildXyzTag(0, maxNits, 0);
        var trc = BuildCurvTag(2.2);
        var desc = BuildMlucTag(description);
        var cprt = BuildMlucTag("Generated by HDRFixer");
        var mhc2 = BuildMhc2Tag(minNits, maxNits, matrix3x4, regammaLut);

        var tags = new (uint sig, byte[] data, bool shared)[] {
            (0x64657363, desc, false), (0x63707274, cprt, false),
            (0x72585953, rXYZ, false), (0x6758595A, gXYZ, false), (0x6258595A, bXYZ, false),
            (0x77747074, wtpt, false), (0x6C756D69, lumi, false),
            (0x72545243, trc, false), (0x67545243, trc, true), (0x62545243, trc, true),
            (0x4D484332, mhc2, false),
        };

        int headerSize = 128;
        int tagTableSize = 4 + tags.Length * 12;
        int dataOffset = headerSize + tagTableSize;
        if (dataOffset % 4 != 0) dataOffset += 4 - (dataOffset % 4);

        var tagOffsets = new int[tags.Length];
        var tagSizes = new int[tags.Length];
        int currentOffset = dataOffset;
        int trcOffset = -1;

        for (int i = 0; i < tags.Length; i++)
        {
            tagSizes[i] = tags[i].data.Length;
            if (tags[i].shared) { tagOffsets[i] = trcOffset; continue; }
            tagOffsets[i] = currentOffset;
            if (tags[i].sig == 0x72545243) trcOffset = currentOffset;
            currentOffset += tags[i].data.Length;
            if (currentOffset % 4 != 0) currentOffset += 4 - (currentOffset % 4);
        }

        int profileSize = currentOffset;
        using var ms = new MemoryStream();
        using var w = new BinaryWriter(ms);

        WriteBE32(w, profileSize); WriteBE32(w, 0); WriteBE32(w, 0x04400000);
        WriteBE32(w, 0x6D6E7472); WriteBE32(w, 0x52474220); WriteBE32(w, 0x58595A20);
        WriteBE16(w, 2026); WriteBE16(w, 2); WriteBE16(w, 18);
        WriteBE16(w, 0); WriteBE16(w, 0); WriteBE16(w, 0);
        WriteBE32(w, 0x61637370); WriteBE32(w, 0x4D534654);
        WriteBE32(w, 0); WriteBE32(w, 0); WriteBE32(w, 0);
        WriteBE32(w, 0); WriteBE32(w, 0); WriteBE32(w, 0); WriteBE32(w, 0); WriteBE32(w, 0);
        WriteBE32(w, ToS15F16(0.9642)); WriteBE32(w, ToS15F16(1.0000)); WriteBE32(w, ToS15F16(0.8249));
        WriteBE32(w, 0);
        for (int i = 0; i < 16; i++) w.Write((byte)0);
        for (int i = 0; i < 20; i++) w.Write((byte)0);

        WriteBE32(w, tags.Length);
        for (int i = 0; i < tags.Length; i++)
        { WriteBE32(w, tags[i].sig); WriteBE32(w, tagOffsets[i]); WriteBE32(w, tagSizes[i]); }

        while (ms.Length < dataOffset) w.Write((byte)0);
        for (int i = 0; i < tags.Length; i++)
        {
            if (tags[i].shared) continue;
            while (ms.Length < tagOffsets[i]) w.Write((byte)0);
            w.Write(tags[i].data);
            while (ms.Length % 4 != 0) w.Write((byte)0);
        }
        while (ms.Length < profileSize) w.Write((byte)0);
        return ms.ToArray();
    }
}
