#include "mhc2_writer.h"
#include <fstream>

namespace hdrfixer::profile {

namespace {

// BT.709 / sRGB primaries in XYZ
constexpr double kRedX = 0.4361, kRedY = 0.2225, kRedZ = 0.0139;
constexpr double kGreenX = 0.3851, kGreenY = 0.7169, kGreenZ = 0.0971;
constexpr double kBlueX = 0.1431, kBlueY = 0.0606, kBlueZ = 0.7141;
constexpr double kWhiteX = 0.9505, kWhiteY = 1.0000, kWhiteZ = 1.0890;
// D50 illuminant for PCS
constexpr double kD50X = 0.9642, kD50Y = 1.0000, kD50Z = 0.8249;

std::vector<uint8_t> build_xyz_tag(double x, double y, double z) {
    std::vector<uint8_t> tag;
    write_tag_sig(tag, "XYZ ");
    write_be32(tag, 0); // reserved
    write_be32_signed(tag, to_s15f16(x));
    write_be32_signed(tag, to_s15f16(y));
    write_be32_signed(tag, to_s15f16(z));
    return tag;
}

std::vector<uint8_t> build_curv_tag(double gamma) {
    std::vector<uint8_t> tag;
    write_tag_sig(tag, "curv");
    write_be32(tag, 0); // reserved
    write_be32(tag, 1); // count = 1 (parametric gamma)
    write_be16(tag, static_cast<uint16_t>(gamma * 256.0));
    write_be16(tag, 0); // padding
    return tag;
}

std::vector<uint8_t> build_mluc_tag(const std::string& text) {
    std::vector<uint8_t> tag;
    write_tag_sig(tag, "mluc");
    write_be32(tag, 0); // reserved
    write_be32(tag, 1); // record count
    write_be32(tag, 12); // record size
    // Language: en-US
    write_be16(tag, 'e'); write_be16(tag, 'n');
    write_be16(tag, 'U'); write_be16(tag, 'S');

    // String length and offset
    uint32_t str_bytes = static_cast<uint32_t>(text.size() * 2);
    write_be32(tag, str_bytes);
    write_be32(tag, 28); // offset to string data

    // UTF-16BE encoded string
    for (char c : text) {
        tag.push_back(0);
        tag.push_back(static_cast<uint8_t>(c));
    }
    pad_to_4(tag);
    return tag;
}

std::vector<uint8_t> build_mhc2_tag(const Mhc2Params& params) {
    std::vector<uint8_t> tag;
    int lut_size = static_cast<int>(params.lut.size());
    if (lut_size < 2) return tag; // LUT too small to be valid

    write_tag_sig(tag, "MHC2");
    write_be32(tag, 0); // reserved
    write_be32(tag, static_cast<uint32_t>(lut_size));
    write_be32_signed(tag, to_s15f16(params.min_nits));
    write_be32_signed(tag, to_s15f16(params.max_nits));

    // Offsets: matrix at 36, lut0 at 84
    uint32_t matrix_offset = 36;
    uint32_t lut0_offset = 84;
    uint32_t lut_data_size = 8 + lut_size * 4; // sf32 sig + reserved + entries
    uint32_t lut1_offset = lut0_offset + lut_data_size;
    uint32_t lut2_offset = lut1_offset + lut_data_size;

    write_be32(tag, matrix_offset);
    write_be32(tag, lut0_offset);
    write_be32(tag, lut1_offset);
    write_be32(tag, lut2_offset);

    // 3x4 identity matrix (12 S15.16 values)
    double matrix[12] = {1,0,0,0, 0,1,0,0, 0,0,1,0};
    for (double v : matrix) {
        write_be32_signed(tag, to_s15f16(v));
    }

    // 3 identical LUTs (R, G, B)
    for (int ch = 0; ch < 3; ++ch) {
        write_tag_sig(tag, "sf32");
        write_be32(tag, 0); // reserved
        for (int i = 0; i < lut_size; ++i) {
            write_be32_signed(tag, to_s15f16(params.lut[i]));
        }
    }

    return tag;
}

} // anonymous namespace

std::vector<uint8_t> generate_mhc2_profile(const Mhc2Params& params) {
    // Build all tag data blobs
    auto desc_tag = build_mluc_tag(params.description);
    auto cprt_tag = build_mluc_tag("Generated by HDRFixer");
    auto rxyz_tag = build_xyz_tag(kRedX, kRedY, kRedZ);
    auto gxyz_tag = build_xyz_tag(kGreenX, kGreenY, kGreenZ);
    auto bxyz_tag = build_xyz_tag(kBlueX, kBlueY, kBlueZ);
    auto wtpt_tag = build_xyz_tag(kWhiteX, kWhiteY, kWhiteZ);
    auto lumi_tag = build_xyz_tag(0, params.max_nits, 0);
    auto trc_tag = build_curv_tag(params.gamma);
    auto mhc2_tag = build_mhc2_tag(params);

    // 11 tags: desc, cprt, rXYZ, gXYZ, bXYZ, wtpt, lumi, rTRC, gTRC, bTRC, MHC2
    // gTRC and bTRC share the same data as rTRC
    constexpr uint32_t tag_count = 11;
    uint32_t tag_table_size = 4 + tag_count * 12; // count + entries
    uint32_t data_start = 128 + tag_table_size;

    uint32_t current_offset = data_start;

    auto align4 = [](uint32_t v) -> uint32_t { return (v + 3) & ~3u; };

    uint32_t desc_off = current_offset; current_offset += align4(static_cast<uint32_t>(desc_tag.size()));
    uint32_t cprt_off = current_offset; current_offset += align4(static_cast<uint32_t>(cprt_tag.size()));
    uint32_t rxyz_off = current_offset; current_offset += align4(static_cast<uint32_t>(rxyz_tag.size()));
    uint32_t gxyz_off = current_offset; current_offset += align4(static_cast<uint32_t>(gxyz_tag.size()));
    uint32_t bxyz_off = current_offset; current_offset += align4(static_cast<uint32_t>(bxyz_tag.size()));
    uint32_t wtpt_off = current_offset; current_offset += align4(static_cast<uint32_t>(wtpt_tag.size()));
    uint32_t lumi_off = current_offset; current_offset += align4(static_cast<uint32_t>(lumi_tag.size()));
    uint32_t trc_off = current_offset; current_offset += align4(static_cast<uint32_t>(trc_tag.size()));
    // gTRC and bTRC share trc_off
    uint32_t mhc2_off = current_offset; current_offset += align4(static_cast<uint32_t>(mhc2_tag.size()));

    uint32_t profile_size = current_offset;

    // Build the profile
    std::vector<uint8_t> profile;
    profile.reserve(profile_size);

    // === ICC HEADER (128 bytes) ===
    write_be32(profile, profile_size);
    write_be32(profile, 0); // preferred CMM
    write_be32(profile, 0x04400000); // version 4.4
    write_tag_sig(profile, "mntr");
    write_tag_sig(profile, "RGB ");
    write_tag_sig(profile, "XYZ ");
    // Date/time (12 bytes)
    write_be16(profile, 2026); write_be16(profile, 2); write_be16(profile, 21);
    write_be16(profile, 0); write_be16(profile, 0); write_be16(profile, 0);
    write_tag_sig(profile, "acsp");
    write_tag_sig(profile, "MSFT");
    write_be32(profile, 0); // flags
    write_be32(profile, 0); // manufacturer
    write_be32(profile, 0); // model
    for (int i = 0; i < 4; ++i) write_be32(profile, 0); // attributes + intent
    // D50 PCS illuminant
    write_be32_signed(profile, to_s15f16(kD50X));
    write_be32_signed(profile, to_s15f16(kD50Y));
    write_be32_signed(profile, to_s15f16(kD50Z));
    write_be32(profile, 0); // creator
    for (int i = 0; i < 4; ++i) write_be32(profile, 0); // profile ID
    for (int i = 0; i < 6; ++i) write_be32(profile, 0); // reserved (24 bytes)

    // === TAG TABLE ===
    write_be32(profile, tag_count);

    auto write_tag_entry = [&](const char* sig, uint32_t offset, uint32_t size) {
        write_tag_sig(profile, sig);
        write_be32(profile, offset);
        write_be32(profile, size);
    };

    write_tag_entry("desc", desc_off, static_cast<uint32_t>(desc_tag.size()));
    write_tag_entry("cprt", cprt_off, static_cast<uint32_t>(cprt_tag.size()));
    write_tag_entry("rXYZ", rxyz_off, static_cast<uint32_t>(rxyz_tag.size()));
    write_tag_entry("gXYZ", gxyz_off, static_cast<uint32_t>(gxyz_tag.size()));
    write_tag_entry("bXYZ", bxyz_off, static_cast<uint32_t>(bxyz_tag.size()));
    write_tag_entry("wtpt", wtpt_off, static_cast<uint32_t>(wtpt_tag.size()));
    write_tag_entry("lumi", lumi_off, static_cast<uint32_t>(lumi_tag.size()));
    write_tag_entry("rTRC", trc_off, static_cast<uint32_t>(trc_tag.size()));
    write_tag_entry("gTRC", trc_off, static_cast<uint32_t>(trc_tag.size())); // shared
    write_tag_entry("bTRC", trc_off, static_cast<uint32_t>(trc_tag.size())); // shared
    write_tag_entry("MHC2", mhc2_off, static_cast<uint32_t>(mhc2_tag.size()));

    // === TAG DATA ===
    auto write_tag_data = [&](const std::vector<uint8_t>& tag, uint32_t expected_off) {
        while (profile.size() < expected_off) profile.push_back(0);
        profile.insert(profile.end(), tag.begin(), tag.end());
    };

    write_tag_data(desc_tag, desc_off);
    write_tag_data(cprt_tag, cprt_off);
    write_tag_data(rxyz_tag, rxyz_off);
    write_tag_data(gxyz_tag, gxyz_off);
    write_tag_data(bxyz_tag, bxyz_off);
    write_tag_data(wtpt_tag, wtpt_off);
    write_tag_data(lumi_tag, lumi_off);
    write_tag_data(trc_tag, trc_off);
    write_tag_data(mhc2_tag, mhc2_off);

    // Pad to final size
    while (profile.size() < profile_size) profile.push_back(0);

    return profile;
}

bool write_profile_to_file(const std::vector<uint8_t>& data, const std::filesystem::path& path) {
    std::ofstream file(path, std::ios::binary);
    if (!file) return false;
    file.write(reinterpret_cast<const char*>(data.data()), data.size());
    return file.good();
}

} // namespace hdrfixer::profile
